--- a/net/minecraft/client/entity/EntityPlayerSP.java
+++ b/net/minecraft/client/entity/EntityPlayerSP.java
@@ -1,5 +1,15 @@
 package net.minecraft.client.entity;
 
+import java.lang.reflect.Field;
+
+import com.mtbs3d.minecrift.api.IBodyAimController;
+import com.mtbs3d.minecrift.gameplay.VRPlayer;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockLiquid;
+import net.minecraft.block.material.Material;
+import com.mtbs3d.minecrift.settings.VRSettings;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.audio.PositionedSoundRecord;
 import net.minecraft.client.gui.GuiCommandBlock;
@@ -26,11 +36,14 @@
 import net.minecraft.entity.ai.attributes.IAttributeInstance;
 import net.minecraft.entity.item.EntityMinecartHopper;
 import net.minecraft.entity.passive.EntityHorse;
+import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.potion.Potion;
+import net.minecraft.src.Reflector;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.tileentity.TileEntityBeacon;
 import net.minecraft.tileentity.TileEntityBrewingStand;
@@ -47,12 +60,13 @@
 import net.minecraft.util.MovementInput;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.Session;
+import net.minecraft.util.Vec3;
 import net.minecraft.world.World;
 
 public class EntityPlayerSP extends AbstractClientPlayer
 {
     public MovementInput movementInput;
-    protected Minecraft mc;
+    protected Minecraft mc; 
 
     /**
      * Used to tell if the player pressed forward twice. If this is at 0 and it's pressed (And they are allowed to
@@ -61,6 +75,20 @@
      */
     protected int sprintToggleTimer;
 
+    // VIVE START - teleport movement
+    public int movementTeleportTimer;
+    // VIVE END - teleport movement
+
+    
+    /** MINECRIFT **/
+    public float headPitch = 0;
+    public double additionX = 0;
+    public double additionZ = 0;
+    public double additionY = 0;
+    public final float PIOVER180 = (float)Math.PI / 180.0F;
+    public Vec3 directionVec = Vec3.createVectorHelper(0, 0, 0);
+    /** END MINECRIFT **/
+    
     /** Ticks left before sprinting is disabled. */
     public int sprintingTicksLeft;
     public float renderArmYaw;
@@ -80,9 +108,23 @@
     public float prevTimeInPortal;
     private static final String __OBFID = "CL_00000938";
 
+    Field inuse, inusedur;
+    
     public EntityPlayerSP(Minecraft p_i1238_1_, World p_i1238_2_, Session p_i1238_3_, int p_i1238_4_)
     {
         super(p_i1238_2_, p_i1238_3_.getProfile());
+        
+		try {
+			inuse = EntityPlayer.class.getDeclaredField("itemInUse");
+	        inuse.setAccessible(true);
+			inusedur = EntityPlayer.class.getDeclaredField("itemInUseCount");
+			inusedur.setAccessible(true);
+		} catch (NoSuchFieldException e) {
+
+		} catch (SecurityException e) {
+
+		}
+       
         this.mc = p_i1238_1_;
         this.dimension = p_i1238_4_;
     }
@@ -99,6 +141,27 @@
         this.renderArmYaw = (float)((double)this.renderArmYaw + (double)(this.rotationYaw - this.renderArmYaw) * 0.5D);
     }
 
+    
+    public void setItemInUseClient(ItemStack item){
+    	
+    	try {
+			this.inuse.set(this, item);
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		}
+    	
+    }
+    
+   public void setItemInUseCountClient(int count){
+    	
+    	try {
+			this.inusedur.set(this, count);
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		}
+    	
+    }
+    
     /**
      * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
      * use this to react to sunlight and start to burn.
@@ -182,7 +245,9 @@
             }
 
             boolean var1 = this.movementInput.jump;
-            float var2 = 0.8F;
+            /** MINECRIFT */
+            float var2 = 0.8F * this.mc.vrSettings.movementSpeedMultiplier;
+            /** END MINECRIFT */
             boolean var3 = this.movementInput.moveForward >= var2;
             this.movementInput.updatePlayerMoveState();
 
@@ -195,20 +260,26 @@
 
             if (this.movementInput.sneak && this.yOffset2 < 0.2F)
             {
-                this.yOffset2 = 0.2F;
+            // VIVE NON NON SVP     this.yOffset2 = 0.2F;
             }
 
-            this.pushOutOfBlocks(this.posX - (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ + (double)this.width * 0.35D);
-            this.pushOutOfBlocks(this.posX - (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ - (double)this.width * 0.35D);
-            this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ - (double)this.width * 0.35D);
-            this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ + (double)this.width * 0.35D);
+            //VIVE CRAWLING
+            
+            this.pushOutOfBlocks(this.posX - (double)this.width * 0.35D, this.boundingBox.minY + this.height, this.posZ + (double)this.width * 0.35D);
+            this.pushOutOfBlocks(this.posX - (double)this.width * 0.35D, this.boundingBox.minY + this.height, this.posZ - (double)this.width * 0.35D);
+            
+            this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + this.height, this.posZ - (double)this.width * 0.35D);
+            this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + this.height, this.posZ + (double)this.width * 0.35D);
+            
+            //CRAWLING
+            
             boolean var4 = (float)this.getFoodStats().getFoodLevel() > 6.0F || this.capabilities.allowFlying;
 
             if (this.onGround && !var3 && this.movementInput.moveForward >= var2 && !this.isSprinting() && var4 && !this.isUsingItem() && !this.isPotionActive(Potion.blindness))
             {
                 if (this.sprintToggleTimer <= 0 && !this.mc.gameSettings.keyBindSprint.getIsKeyPressed())
                 {
-                    this.sprintToggleTimer = 7;
+                    this.sprintToggleTimer = 14;
                 }
                 else
                 {
@@ -240,18 +311,24 @@
                 }
             }
 
+            /** MINECRIFT **/
             if (this.capabilities.isFlying)
             {
+                // Account for inertia factor
+                int inertiaFactor = Minecraft.getMinecraft().vrSettings.inertiaFactor;
+                double addFactor = VRSettings.getInertiaAddFactor(inertiaFactor);
+
                 if (this.movementInput.sneak)
                 {
-                    this.motionY -= 0.15D;
+                    this.motionY -= 0.15D * addFactor;
                 }
 
                 if (this.movementInput.jump)
                 {
-                    this.motionY += 0.15D;
+                    this.motionY += 0.15D * addFactor;
                 }
             }
+            /** END MINECRIFT **/
 
             if (this.isRidingHorse())
             {
@@ -296,6 +373,10 @@
 
             super.onLivingUpdate();
 
+            // VIVE START - teleport movement
+            mc.vrPlayer.onLivingUpdate(this, this.mc, this.rand);
+            // VIVE END - teleport movement
+
             if (this.onGround && this.capabilities.isFlying)
             {
                 this.capabilities.isFlying = false;
@@ -341,7 +422,15 @@
             var1 *= 1.0F - var4 * 0.15F;
         }
 
-        return var1;
+        /** MINECRIFT FORGE **/
+        if (Reflector.forgeExists()) {
+            //return ForgeHooksClient.getOffsetFOV(this, var1);
+            return (Float)Reflector.call(Reflector.ForgeHooksClient_getOffsetFov, new Object[] {this, var1});
+        }
+        else {
+            return var1;
+        }
+        /** END MINECRIFT FORGE **/
     }
 
     /**
@@ -524,70 +613,170 @@
     {
         return this.worldObj.getBlock(p_71153_1_, p_71153_2_, p_71153_3_).isNormalCube();
     }
-
+    /** MINECRIFT FORGE **/
+    private boolean isHeadspaceFree(int x, int y, int z, int height)
+    {
+        for (int i1 = 0; i1 < height; i1++)
+        {
+            if (isBlockNormal(x, y + i1, z + 1)) return false;
+        }
+        return true;
+    }
+    /** END MINECRIFT FORGE **/
     protected boolean pushOutOfBlocks(double x, double y, double z)
     {
-        int var7 = MathHelper.floor_double(x);
-        int var8 = MathHelper.floor_double(y);
-        int var9 = MathHelper.floor_double(z);
-        double var10 = x - (double)var7;
-        double var12 = z - (double)var9;
-
-        if (this.isBlockNormal(var7, var8, var9) || this.isBlockNormal(var7, var8 + 1, var9))
+        if (this.noClip)
         {
-            boolean var14 = !this.isBlockNormal(var7 - 1, var8, var9) && !this.isBlockNormal(var7 - 1, var8 + 1, var9);
-            boolean var15 = !this.isBlockNormal(var7 + 1, var8, var9) && !this.isBlockNormal(var7 + 1, var8 + 1, var9);
-            boolean var16 = !this.isBlockNormal(var7, var8, var9 - 1) && !this.isBlockNormal(var7, var8 + 1, var9 - 1);
-            boolean var17 = !this.isBlockNormal(var7, var8, var9 + 1) && !this.isBlockNormal(var7, var8 + 1, var9 + 1);
-            byte var18 = -1;
-            double var19 = 9999.0D;
+            return false;
+        }
+    	
+        /** MINECRIFT FORGE **/
+        if (Reflector.forgeExists()) {
+     
+            int i = MathHelper.floor_double(x);
+            int j = MathHelper.floor_double(y);
+            int k = MathHelper.floor_double(z);
+            double d3 = x - (double)i;
+            double d4 = z - (double)k;
 
-            if (var14 && var10 < var19)
-            {
-                var19 = var10;
-                var18 = 0;
-            }
+            int entHeight = Math.max(Math.round(this.height), 1);
 
-            if (var15 && 1.0D - var10 < var19)
-            {
-                var19 = 1.0D - var10;
-                var18 = 1;
-            }
+            boolean inTranslucentBlock = true;
 
-            if (var16 && var12 < var19)
+            for (int i1 = 0; i1 < entHeight; i1++)
             {
-                var19 = var12;
-                var18 = 4;
+                if (!this.isBlockNormal(i, j + i1, k))
+                {
+                    inTranslucentBlock = false;
+                }
             }
 
-            if (var17 && 1.0D - var12 < var19)
+            if (inTranslucentBlock)
             {
-                var19 = 1.0D - var12;
-                var18 = 5;
-            }
+                boolean flag  = !isHeadspaceFree(i - 1, j, k, entHeight);
+                boolean flag1 = !isHeadspaceFree(i + 1, j, k, entHeight);
+                boolean flag2 = !isHeadspaceFree(i, j, k - 1, entHeight);
+                boolean flag3 = !isHeadspaceFree(i, j, k + 1, entHeight);
+                byte b0 = -1;
+                double d5 = 9999.0D;
 
-            float var21 = 0.1F;
+                if (flag && d3 < d5)
+                {
+                    d5 = d3;
+                    b0 = 0;
+                }
 
-            if (var18 == 0)
-            {
-                this.motionX = (double)(-var21);
-            }
+                if (flag1 && 1.0D - d3 < d5)
+                {
+                    d5 = 1.0D - d3;
+                    b0 = 1;
+                }
 
-            if (var18 == 1)
-            {
-                this.motionX = (double)var21;
-            }
+                if (flag2 && d4 < d5)
+                {
+                    d5 = d4;
+                    b0 = 4;
+                }
 
-            if (var18 == 4)
-            {
-                this.motionZ = (double)(-var21);
+                if (flag3 && 1.0D - d4 < d5)
+                {
+                    d5 = 1.0D - d4;
+                    b0 = 5;
+                }
+
+                float f = 0.1F;
+
+                if (b0 == 0)
+                {
+                    this.motionX = (double)(-f);
+                }
+
+                if (b0 == 1)
+                {
+                    this.motionX = (double)f;
+                }
+
+                if (b0 == 4)
+                {
+                    this.motionZ = (double)(-f);
+                }
+
+                if (b0 == 5)
+                {
+                    this.motionZ = (double)f;
+                }
             }
+        }
+        else {
+            /** END MINECRIFT FORGE **/
+            int var7 = MathHelper.floor_double(x);
+            int var8 = MathHelper.floor_double(y);
+            int var9 = MathHelper.floor_double(z);
+            double var10 = x - (double)var7;
+            double var12 = z - (double)var9;
+
+            //CRAWLING
+            boolean tall = Math.floor(this.height) > 0;
+            //
+                        
+            if ((tall && this.isBlockNormal(var7, var8 - 1 , var9)) || this.isBlockNormal(var7, var8, var9))
+            {
+                boolean var14 = !this.isBlockNormal(var7 - 1, var8, var9) && !this.isBlockNormal(var7 - 1, var8 + 1, var9);
+                boolean var15 = !this.isBlockNormal(var7 + 1, var8, var9) && !this.isBlockNormal(var7 + 1, var8 + 1, var9);
+                boolean var16 = !this.isBlockNormal(var7, var8, var9 - 1) && !this.isBlockNormal(var7, var8 + 1, var9 - 1);
+                boolean var17 = !this.isBlockNormal(var7, var8, var9 + 1) && !this.isBlockNormal(var7, var8 + 1, var9 + 1);
+                byte var18 = -1;
+                double var19 = 9999.0D;
 
-            if (var18 == 5)
-            {
-                this.motionZ = (double)var21;
+                if (var14 && var10 < var19)
+                {
+                    var19 = var10;
+                    var18 = 0;
+                }
+
+                if (var15 && 1.0D - var10 < var19)
+                {
+                    var19 = 1.0D - var10;
+                    var18 = 1;
+                }
+
+                if (var16 && var12 < var19)
+                {
+                    var19 = var12;
+                    var18 = 4;
+                }
+
+                if (var17 && 1.0D - var12 < var19)
+                {
+                    var19 = 1.0D - var12;
+                    var18 = 5;
+                }
+
+                float var21 = 0.1F;
+
+                if (var18 == 0)
+                {
+                    this.motionX = (double)(-var21);
+                }
+
+                if (var18 == 1)
+                {
+                    this.motionX = (double)var21;
+                }
+
+                if (var18 == 4)
+                {
+                    this.motionZ = (double)(-var21);
+                }
+
+                if (var18 == 5)
+                {
+                    this.motionZ = (double)var21;
+                }
             }
+            /** MINECRIFT FORGE **/
         }
+        /** END MINECRIFT FORGE **/
 
         return false;
     }
@@ -640,6 +829,20 @@
 
     public void playSound(String name, float volume, float pitch)
     {
+        /** MINECRIFT FORGE **/
+        if (Reflector.forgeExists()) {
+            Object event = Reflector.newInstance(Reflector.ForgePlaySoundAtEntityEvent_Constructor, new Object[] {this, name, volume, pitch});
+            if (Reflector.postForgeBusEvent(event)) {
+                return;
+            }
+            name = (String)Reflector.getFieldValue(event, Reflector.ForgePlaySoundAtEntityEvent_name);
+//            net.minecraftforge.event.entity.PlaySoundAtEntityEvent event = new net.minecraftforge.event.entity.PlaySoundAtEntityEvent(this, name, volume, pitch);
+//            if (MinecraftForge.EVENT_BUS.post(event)) {
+//                return;
+//            }
+//            name = event.name;
+        }
+        /** END MINECRIFT FORGE **/
         this.worldObj.playSound(this.posX, this.posY - (double)this.yOffset, this.posZ, name, volume, pitch, false);
     }
 
@@ -662,4 +865,224 @@
     }
 
     protected void sendHorseJump() {}
+
+    /**** MINECRIFT ADDITIONS BELOW ****/
+    
+    
+    /** MINECRIFT **/
+    public void doDrag(float var3, boolean isFlying)
+    {
+        double xFactor = var3;
+        double zFactor = var3;
+        double yFactor = 0.9800000190734863D;
+
+        if (this instanceof EntityPlayer)
+        {
+        	int inertiaFactor = Minecraft.getMinecraft().vrSettings.inertiaFactor;
+        	double addFactor = VRSettings.getInertiaAddFactor(inertiaFactor);
+
+        	double boundedAdditionX = getBoundedAddition(additionX);
+        	double targetLimitX = (var3 * boundedAdditionX) / (1f - var3);
+        	double multiFactorX = targetLimitX / (var3 * (targetLimitX + (boundedAdditionX * addFactor)));
+        	xFactor *= multiFactorX;
+
+        	double boundedAdditionZ = getBoundedAddition(additionZ);
+        	double targetLimitZ = (var3 * boundedAdditionZ) / (1f - var3);
+        	double multiFactorZ = targetLimitZ / (var3 * (targetLimitZ + (boundedAdditionZ * addFactor)));
+        	zFactor *= multiFactorZ;
+
+        	yFactor = var3;
+        	double boundedAdditionY = getBoundedAddition(additionY);
+        	double targetLimitY = (var3 * boundedAdditionY) / (1f - var3);
+        	double multiFactorY = targetLimitY / (var3 * (targetLimitY + (boundedAdditionY * addFactor)));
+        	yFactor *= multiFactorY;
+        }
+
+        this.motionY *= yFactor;
+        this.motionX *= xFactor;
+        this.motionZ *= zFactor;
+    }
+    
+    public double getBoundedAddition(double orig)
+    {
+        if (orig >= -1.0E-6D && orig <= 1.0E-6D) {
+            return 1.0E-6D;
+        }
+        else {
+            return orig;
+        }
+    }
+    
+    
+    /**
+     * Used in both water and by flying objects
+     */
+    @Override
+    public void moveFlying(float strafe, float forward, float friction)
+    {
+  //  	super.moveFlying(strafe, forward, friction, allowYAdjust);;
+    	
+    	VRPlayer vr = mc.vrPlayer;		
+    	if (!vr.getFreeMoveMode()) {return;}
+		
+        int inertiaFactor = Minecraft.getMinecraft().vrSettings.inertiaFactor;
+        float var4 = strafe * strafe + forward * forward;
+
+        double mX = 0d;
+        double mZ = 0d;
+        double mY = 0d;
+        double addFactor = 1f;
+        double yAddFactor = 0f;
+
+        if (var4 >= 1.0E-4F)
+        {
+            var4 = MathHelper.sqrt_float(var4);
+
+            if (var4 < 1.0F)
+            {
+                var4 = 1.0F;
+            }
+
+            var4 = friction / var4;
+            strafe *= var4;
+            forward *= var4;
+
+            directionVec.xCoord = strafe;
+            directionVec.yCoord = 0;
+            directionVec.zCoord = forward;
+	  						
+         	//VIVE DO PITCH FLYING		
+
+    		IBodyAimController con = mc.lookaimController;
+    		
+    	   // Modify acceleration sequence (each tick)
+            addFactor = VRSettings.getInertiaAddFactor(inertiaFactor);
+    				
+            // Account for pitch if required
+            if (Minecraft.getMinecraft().vrSettings.allowPitchAffectsHeightWhileFlying) {
+                yAddFactor = addFactor;
+    			if (vr.useLControllerForRestricedMovement) {
+    	
+    				if (con instanceof MCOpenVR) {
+    				  directionVec.rotateAroundX(-(((MCOpenVR)con).laimPitch) * PIOVER180);		   
+    				}
+    					 
+    			} else {
+    		       directionVec.rotateAroundX(-this.headPitch * PIOVER180);	
+    			}		
+            }
+    		
+    		// Account for yaw
+    		if (vr.useLControllerForRestricedMovement) {
+    				if (con instanceof MCOpenVR) {
+    				  directionVec.rotateAroundY(-(((MCOpenVR)con).laimYaw) * PIOVER180);		   
+    				}
+    		} else {
+    			directionVec.rotateAroundY(-this.rotationYaw * PIOVER180);
+    		}
+    	
+		
+            mX = directionVec.xCoord;
+            mY = directionVec.yCoord;
+            mZ = directionVec.zCoord;
+           
+            this.motionX = this.motionX + (mX * addFactor);
+            this.motionZ = this.motionZ + (mZ * addFactor);
+            this.motionY = this.motionY + (mY * yAddFactor);
+      
+        }
+        //if (this instanceof EntityPlayerSP) {
+        //    System.out.println(String.format("FLYING: %B, forward: %.4f, strafe: %.4f, pitch: %.4f, yaw: %.4f, mx: %.4f, mz: %.4f, my: %.4f", allowYAdjust, forward, strafe, this.headPitch, this.rotationYaw, mX, mZ, mY));
+        //}
+
+        this.additionX = mX;
+        this.additionZ = mZ;
+        this.additionY = mY;
+/** END MINECRIFT **/
+   
+    }
+    
+    /**
+     * Checks if the current block the entity is within of the specified material type
+     */
+    @Override
+    public boolean isInsideOfMaterial(Material materialIn)
+    {
+        double var2 = this.posY + (double) this.getEyeHeight();  // TODO: Use actual centre-eye position
+        int var4 = MathHelper.floor_double(this.posX);
+        int var5 = MathHelper.floor_float((float) MathHelper.floor_double(var2));
+        int var6 = MathHelper.floor_double(this.posZ);
+        Block var7 = this.worldObj.getBlock(var4, var5, var6);
+
+        if (var7.getMaterial() == materialIn)
+        {
+            float var8 = BlockLiquid.getLiquidHeightPercent(this.worldObj.getBlockMetadata(var4, var5, var6)) - 0.11111111F;
+            float var9 = (float) (var5 + 1) - var8;
+            return var2 < (double) var9;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    // VIVE START - update room origin when player entity is moved
+    public void setPositionAndRotation(double x, double y, double z, float yaw, float pitch)
+    {
+        super.setPositionAndRotation(x, y, z, yaw, pitch);
+        VRPlayer.get().snapRoomOriginToPlayerEntity(this);
+    }
+
+    public void readFromNBT(NBTTagCompound tagCompund)
+    {
+        super.readFromNBT(tagCompund);
+        VRPlayer.get().snapRoomOriginToPlayerEntity(this);
+    }
+
+    public void setPosition(double x, double y, double z)
+    {
+        super.setPosition(x, y, z);
+        VRPlayer.get().snapRoomOriginToPlayerEntity(this);
+    }
+    
+    @Override
+    public void moveEntity(double x, double y, double z)
+    {
+    	boolean client = this instanceof EntityPlayerSP;
+    	boolean freemove = VRPlayer.get().getFreeMoveMode();
+    	boolean doY = freemove || (Minecraft.getMinecraft().vrSettings.simulateFalling && !this.isOnLadder()) && !this.isSneaking();
+    	Vec3 roomOrigin = VRPlayer.get().getRoomOrigin();
+    	Vec3 camloc = Minecraft.getMinecraft().entityRenderer.getCameraLocation();
+
+    	if (freemove && (this.moveForward != 0 || Math.abs(this.motionX) > 0.01 || Math.abs(this.motionZ) > 0.01))
+    	{
+    		double ox = roomOrigin.xCoord - posX;
+    		double oz = roomOrigin.zCoord - posZ;
+    		super.moveEntity(x,y,z);
+
+    		if (client){	
+    			VRPlayer.get().setRoomOrigin(
+    					posX + ox, 
+    					this.boundingBox.minY, 
+    					posZ  + oz);
+    					}
+    		//	VRPlayer.get().snapRoomOriginToPlayerEntity((EntityPlayerSP) this);
+
+    	} else {
+    		if(doY) {      	 
+    			super.moveEntity(0,y,0);
+    			if (client){
+    				VRPlayer.get().setRoomOrigin(
+    					VRPlayer.get().getRoomOrigin().xCoord, 
+    					this.boundingBox.minY, 
+    					VRPlayer.get().getRoomOrigin().zCoord);
+    			}
+
+    		} else {
+    			//do not move player, VRPlayer.moveplayerinroom will move him around.
+    		}
+    	}
+    }
+    
+    
 }
